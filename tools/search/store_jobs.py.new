#!/usr/bin/env python3
"""
Command-line tool for searching LinkedIn jobs and storing them directly in the database.
This tool builds on search_jobs.py but adds direct database integration.
"""

import os
import sys
import logging
from datetime import datetime

# Import from common modules using relative imports
from ..common.utils import setup_path, setup_logging
from ..common.progress_display import ProgressDisplay, ProgressStyle

# Import local modules using relative imports
from .cli import parse_args
from .pipeline import JobPipeline

# Initial path setup
setup_path()  # Ensure paths are properly set up

def main():
    """Main entry point for the script."""
    try:
        # Parse command line arguments
        args = parse_args()
        
        # Set up logging
        log_file = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 
                               'logs', 
                               f"linkedin_jobs_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        
        # Determine if we should use the progress display
        use_progress = not args.no_progress
        
        # Configure logging - only log to console if progress display is disabled
        logger = setup_logging(
            args.verbose, 
            log_file, 
            'store_jobs',
            console_output=(not use_progress)
        )
        
        # Initialize progress display if enabled
        progress = None
        if use_progress:
            style = ProgressStyle.BASIC if args.basic_progress else ProgressStyle.ANIMATED
            progress = ProgressDisplay(style=style)
            
        # Log startup information
        logger.info("=" * 80)
        logger.info("LinkedIn Job Search and Storage Tool")
        logger.info("=" * 80)
        
        # Create and run the pipeline
        pipeline = JobPipeline(args, progress)
        exit_code = pipeline.run()
        
        # Finalize progress display if active
        if progress:
            progress.finalize()
            
        return exit_code
        
    except KeyboardInterrupt:
        logger.info("\nOperation interrupted by user. Exiting.")
        
        if progress:
            progress.update(status_message="Operation interrupted by user")
            progress.finalize()
            
        return 130  # Standard exit code for SIGINT
        
    except Exception as e:
        logger.error(f"Unhandled exception: {e}")
        
        if progress:
            progress.update(status_message=f"Error: {str(e)[:50]}...")
            progress.finalize()
            
        return 1

if __name__ == "__main__":
    sys.exit(main())